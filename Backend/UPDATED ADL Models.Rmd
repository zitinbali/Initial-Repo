
```{r import, warning = FALSE, results= "hide", echo = FALSE}

source("GDP Cleaning.R")
source("inputs.R")

```

# Basic GDP Prep 

```{r gdp prep, warning=FALSE}

spliced_GDP <- data_splice(RGDP_Data, "1947 Q1", "2023 Q4", "1965 Q4", 
                           "2024 Q1", example_startyq, example_endyq, 3, 0)

post_prep_gdp <- prep_func(spliced_GDP, 40)
post_prep_gdp_df <- post_prep_gdp$df
post_prep_gdp_delta = post_prep_gdp$delta

# revise GDP values

# note that the last input should be in a string format
sliced_perc_change <- data_splice(perc_change_df, "1947 Q2", "2023 Q4", 
                                  "1965 Q4", "2024 Q1", 
                                  example_startq, example_endq, 2, 1)
all_GDP_data <- revise_values(sliced_perc_change, post_prep_gdp_delta, 
                              example_startq, example_endq)

GDPGrowth_ts <- ts(all_GDP_data, 
                  start = c(start_y, start_q), 
                  end = c(end_y, end_q), 
                  frequency = 4)
```

# AR Function 

```{r AR function}

# Using the basic AR model from lecture 
# Inputs: Y - predicted variable, p - AR order, h - forecast horizon

fitAR=function(Y,h, dum){
  
  minimum = Inf
  
  for (p in 1:4){
    # create p lags + forecast horizon shift (=h option)
    aux = embed(Y, p+h)
    
    #  Y variable aligned/adjusted for missing data due to lags
    y = aux[,1] 
    
    # lags of Y (predictors) corresponding to forecast horizon (prevent leakage)
    X = as.matrix(aux[,-c(1:(ncol(Y)*h))])
  
    # retrieve last p observations
    X.out = tail(aux,1)[1:ncol(X)] 
    
    # cutting dummy to shape
    dum = tail(dum, length(y))
  
    # estimate direct h-step AR(p) by OLS 
    model = lm(y~X+dum) 
    
    # extract coefficients
    coef = coef(model)[1:(ncol(X)+1)]
  
    #make a forecast using the last few observations: a direct h-step forecast.
    pred = c(1,X.out)%*%coef 
    
    #note the addition of a constant to the test observation vector
    
    #get unadjusted rmsfe (ignoring estimation uncertainty)
    rmsfe = sqrt(sum(model$residuals^2)/nrow(X))
    aic = AIC(model)
    
    if(aic < minimum){
      minimum = aic
      best_rmsfe = rmsfe
      best_p = p
      best_model = model
      best_pred = pred
      best_coef = coef
    }
  }
  
  
  #save estimated AR regression, prediction, and estimated coefficients
  return(list("model"=best_model,"pred"=best_pred,"coef"=best_coef, "rmsfe" = best_rmsfe, "aic"=minimum, "p" = best_p)) 
}

```


# ADL Model - Splicing Function 

```{r adl splice function}

ADL_splice <- function(data, window_start, window_end){
  start_rownum = which(grepl(window_start, data$Date))
  end_rownum = which(grepl(window_end, data$Date))

  output <- data[start_rownum:end_rownum+1, ]
  
  return(output)
}

```


# Selecting Best Model - AIC 

```{r aic}

#end_year, end_quarter differ for the ADL function; can't be hardcoded

AICselector <- function(Y_df, X_df, end_year, end_quarter, dum){
  
  # options is a vector that comprises all the lags of Y and X. 
  # These are the options for permutations and combinations
  options <- c()
  for (j in 1:4){
    Y_string = paste("L(", "Y_df", ",", j, ")", sep = "")
    X_string = paste("L(", "X_df", ",", j, ")", sep = "")
    options <- append(options, Y_string)
    options <- append(options, X_string)
  }
  
  dum_string = as.character(substitute(dum))
  # creates the "GDPGrowth_ts ~ " part
  #start_string = paste("Y_df", " ~ ", sep = "")
  start_string = "Y_df ~ dum + "
  
  # just a really large value
  min_AIC = Inf
  min_AIC_string = ""
  
  for (i in 1:4){
    store = combn(options, i)
    length_store = ncol(store)
  
    for (m in 1:length_store){
      elements <- store[,m]
      body_string = ""
      
      for (n in 1:i){
        body_string = paste(body_string, elements[n], sep = " + ")
        # remove the first plus sign
        body_string_up <- substring(body_string, 4)
        
        model_string = paste(start_string, body_string_up, sep = "")
        model_formula = as.formula(model_string)
      
        # create dynlm model 
        model_local <- dynlm(model_formula,
                             start = c(start_y, start_q), 
                             end = c(end_year, end_quarter))
        
        # AIC of model 
        AIC_local <- AIC(model_local)
        
        # if AIC_local < min_AIC, replace the value of min_AIC. 
        # replace min_AIC_string too
        if(AIC_local < min_AIC){
          min_AIC = AIC_local
          min_AIC_string = model_string
        }
      }
    }
  }
  final_string = gsub("dum", dum_string, min_AIC_string)
  # output is the string format of the optimal model formula
  return(final_string)
}


```


# Function for calculating next quarter prediction

```{r next quarter}

ADL_predict_1 <- function(Y_dataframe, X_dataframe, Y_string, X_string,
                          selectors, coefficients){
  
  coef_df <- as.data.frame(coefficients)
  coef_row_name <- c(rownames(coef_df))
  
  input_string <- as.character(selectors)
  
  Y_lags <- str_count(input_string, Y_string) - 1
  X_lags <- str_count(input_string, X_string) 
  
  # error proof: number of lags is accurate 
  
  Y_lag_names <- c()
  for (x in (1:length(coef_row_name))){
    if (grepl(Y_string, coef_row_name[x], fixed = TRUE)){
      # string of lag 
      str <- coef_row_name[x]
      Y_lag_names <- append(Y_lag_names, str)
    }
  }
    
  X_lag_names <- c()
  for (y in (1:length(coef_row_name))){
    if (grepl(X_string, coef_row_name[y], fixed = TRUE)){
      # string of lag 
      str <- coef_row_name[y]
      X_lag_names <- append(X_lag_names, str)
    }
  }
  
  pred = coefficients[[1]]
  
  
  if (Y_lags == 0){
    if (X_lags == 0){
      # if Y_lags = 0 and X_lags = 0
      pred = pred
    } 
    else {
      # if Y_lags = 0 and X_lags != 0
      for (i in 1:X_lags){
        # create lag string 
        lag_string <- X_lag_names[i]
        coeff_value = coef_df[lag_string,]
        
        tail_num_i = as.numeric(str_sub(lag_string,-2,-2))
        
        temp = (tail(X_dataframe, n = tail_num_i)[1]) * coeff_value
        pred = pred + temp
      }
    }
  } 
  else if (X_lags == 0){
    # if Y_lags != 0 and X_lags = 0
    
    for (j in 1:Y_lags){
      # create lag string 
      lag_string <- Y_lag_names[j]
      coeff_value = coef_df[lag_string,]
      
      tail_num_j = as.numeric(str_sub(lag_string,-2,-2))
      
      temp = (tail(Y_dataframe, n = tail_num_j)[1]) * coeff_value
      pred = pred + temp
    }
  } 
  else {
    # if Y_lags != 0 and X_lags != 0 
      for (p in 1:Y_lags){
        # create lag string 
        lag_string <- Y_lag_names[p]
        coeff_value = coef_df[lag_string,]
        
        tail_num_p = as.numeric(str_sub(lag_string,-2,-2))
        
        temp = (tail(Y_dataframe, n = tail_num_p)[1]) * coeff_value
        
        pred = pred + temp
        
      }
      for (q in 1:X_lags){
        # create lag string 
        lag_string <- X_lag_names[q]
        coeff_value = coef_df[lag_string,]
        
        tail_num_q = as.numeric(str_sub(lag_string,-2,-2))
        
        temp = (tail(X_dataframe, n = tail_num_q)[1]) * coeff_value
        pred = pred + temp
      }
    }

  return(pred)
}


```




# Function for calculating predictions for all time horizons

```{r predict all horizons}

# note that Y_dataframe and X_dataframe are in ts form
ADL_predict_all <- function(Y_dataframe, X_dataframe, f_horizon){
  selectors_AIC <- AICselector(Y_dataframe, X_dataframe, end_y, end_q, covid_dummy)
  
  Y_string <- as.character(substitute(Y_dataframe))
  X_string <- as.character(substitute(X_dataframe))
  
  selectors_AIC <- gsub("Y_df", Y_string, selectors_AIC) 
  selectors_AIC <- gsub("X_df", X_string, selectors_AIC)
  
  model_formula = as.formula(selectors_AIC)

  model_AIC <- dynlm(model_formula,
        start = c(start_y, start_q), 
        end = c(end_y, end_q))
  
  
  pred <- ADL_predict_1(Y_dataframe, X_dataframe, Y_string, X_string,
                        selectors_AIC, model_AIC$coefficients)
  
  X_df <- as.matrix(X_dataframe)
  GDP_df <- as.matrix(Y_dataframe)
  
  # X pred 
  AR_output <- fitAR(X_df, 1, covid_dummy)
  X_pred <- AR_output$pred
  
  if (f_horizon == 1){
    pred = pred
  }
  
  else{
    for (i in 2:f_horizon){
      
      # updating end year & quarter 
      updated_end_yq <- example_endyq + (i - 1)/4
      upd_end_y <- as.numeric(year(updated_end_yq))
      upd_end_q <- as.numeric(quarter(updated_end_yq))
      
      # replace the NA in the last row with the prediction above
      GDP_df <- rbind(GDP_df, pred)
      
      gdp_ts <- ts(GDP_df, 
                  start = c(start_y, start_q), 
                  end = c(upd_end_y, upd_end_q), 
                  frequency = 4)
      
      # X pred
      X_df <- rbind(X_df, X_pred)
      
      X_ts <- ts(X_df, 
                start = c(start_y, start_q), 
                end = c(upd_end_y, upd_end_q), 
                frequency = 4)
      
      # Updating COVID dummy
      upd_covid_dummy = c(covid_dummy, rep(0, i - 1))
      
      # Formula recommended by AIC selector
      selectors_AIC_local <- AICselector(gdp_ts, X_ts, upd_end_y, upd_end_q, upd_covid_dummy)
      
      selectors_AIC_local <- gsub("Y_df", "gdp_ts", selectors_AIC_local) 
      selectors_AIC_local <- gsub("X_df", "X_ts", selectors_AIC_local)
      
      
      # model based on AIC selection
      model_AIC_local <- dynlm(as.formula(selectors_AIC_local),
            start = c(start_y, start_q), 
            end = c(upd_end_y, upd_end_q))
        
      pred <- ADL_predict_1(gdp_ts, X_ts, "gdp_ts", "X_ts",
                            selectors_AIC_local, model_AIC_local$coefficients)
      
      AR_output_new <- fitAR(X_df, i, covid_dummy)
      X_pred <- AR_output_new$pred
      
      
    }
  }

  return (pred)
}

```


# ADL Model - BAA-AAA Spread 

```{r adl model baa-aaa}

baa_aaa <- read_excel("../Data/FRED BAA-AAA Data.xls", 
                      col_names = c("Date", "Spread")) %>% 
  mutate(Date = as.yearqtr(Date), 
         Spread = as.numeric(Spread))

baa_aaa <- ADL_splice(baa_aaa, example_startyq, example_endyq)
  
baa_aaa_ts <- ts(baa_aaa$Spread, 
                start = c(start_y, start_q), 
                end = c(end_y, end_q), 
                frequency = 4)

plot(merge(as.zoo(GDPGrowth_ts), as.zoo(baa_aaa_ts)), 
     plot.type = "single", 
     col = c("darkred", "steelblue"),
     lwd = 2,
     xlab = "Date",
     ylab = "",
     main = "BAA-AAA Spread & GDP Growth over Time")

legend("topright", 
       legend = c("GDP Growth", "BAA-AAA Spread"),
       col = c("darkred", "steelblue"),
       lwd = c(1, 1),
       cex = 0.5)

BAA_AAA_prediction <- ADL_predict_all(GDPGrowth_ts, baa_aaa_ts, example_fhorizon)
ADL_predict_all(GDPGrowth_ts, baa_aaa_ts, 1)
ADL_predict_all(GDPGrowth_ts, baa_aaa_ts, 2)
ADL_predict_all(GDPGrowth_ts, baa_aaa_ts, 3)
ADL_predict_all(GDPGrowth_ts, baa_aaa_ts, 4)

```

# ADL Model - Treasury Spread 

```{r adl model treasury}

tspread <- read_excel("../Data/FRED Treasury Spread.xls", col_names = c("Date", "Spread")) %>% 
  mutate(Date = as.yearqtr(Date), 
         Spread = as.numeric(Spread))

# NOTE: tspread is only from 1976 Q4 onward, so we can't accept forecast horizons earlier, at least not for this ADL model

tspread <- ADL_splice(tspread, example_startyq, example_endyq)

tspread_ts <- ts(tspread$Spread, 
                start = c(start_y, start_q), 
                end = c(end_y, end_q), 
                frequency = 4)

plot(merge(as.zoo(GDPGrowth_ts), as.zoo(tspread_ts)), 
     plot.type = "single", 
     col = c("darkred", "steelblue"),
     lwd = 2,
     xlab = "Date",
     ylab = "",
     main = "Treasury Spread & GDP Growth over Time")
legend("topright", 
       legend = c("GDP Growth", "Treasury Spread"),
       col = c("darkred", "steelblue"),
       lwd = c(1, 1),
       cex = 0.5)

tspread_prediction <- ADL_predict_all(GDPGrowth_ts, tspread_ts, example_fhorizon)
ADL_predict_all(GDPGrowth_ts, tspread_ts, 1)
ADL_predict_all(GDPGrowth_ts, tspread_ts, 2)
ADL_predict_all(GDPGrowth_ts, tspread_ts, 3)
ADL_predict_all(GDPGrowth_ts, tspread_ts, 4)

```




# ADL Model - FRED Hstarts

```{r adl model fred hstarts}

fred_hstarts <- read_excel("../Data/FRED Hstarts.xls", col_names = c("Date", "Spread")) %>% 
  mutate(Date = as.yearqtr(Date), 
         Spread = as.numeric(Spread))

fred_hstarts <- ADL_splice(fred_hstarts, example_startyq, example_endyq)

fred_hstarts_ts <- ts(fred_hstarts$Spread, 
                start = c(start_y, start_q), 
                end = c(end_y, end_q), 
                frequency = 4)

plot(merge(as.zoo(GDPGrowth_ts), as.zoo(fred_hstarts_ts)), 
     plot.type = "single", 
     col = c("darkred", "steelblue"),
     lwd = 2,
     xlab = "Date",
     ylab = "",
     main = "Housing Starts & GDP Growth over Time")
legend("topright", 
       legend = c("GDP Growth", "Housing Starts"),
       col = c("darkred", "steelblue"),
       lwd = c(1, 1),
       cex = 0.5)

hstarts_prediction <- ADL_predict_all(GDPGrowth_ts, fred_hstarts_ts, example_fhorizon)
ADL_predict_all(GDPGrowth_ts, fred_hstarts_ts, 1)
ADL_predict_all(GDPGrowth_ts, fred_hstarts_ts, 2)
ADL_predict_all(GDPGrowth_ts, fred_hstarts_ts, 3)
ADL_predict_all(GDPGrowth_ts, fred_hstarts_ts, 4)

```



# ADL Model - Consumer Sentiment

```{r adl model consent}

consent <- read_excel("../Data/FRED Consumer Sentiment.xls", col_names = c("Date", "Spread")) %>% 
  mutate(Date = as.yearqtr(Date), 
         Spread = as.numeric(Spread))

consent <- ADL_splice(consent, example_startyq, example_endyq)

consent_ts <- ts(consent$Spread, 
                start = c(start_y, start_q), 
                end = c(end_y, end_q), 
                frequency = 4)

plot(merge(as.zoo(GDPGrowth_ts), as.zoo(consent_ts)), 
     plot.type = "single", 
     col = c("darkred", "steelblue"),
     lwd = 2,
     xlab = "Date",
     ylab = "",
     main = "Consumer Sentiment & GDP Growth over Time")
legend("topright", 
       legend = c("GDP Growth", "Consumer Sentiment"),
       col = c("darkred", "steelblue"),
       lwd = c(1, 1),
       cex = 0.5)

consent_prediction <- ADL_predict_all(GDPGrowth_ts, consent_ts, example_fhorizon)
ADL_predict_all(GDPGrowth_ts, consent_ts, 1)
ADL_predict_all(GDPGrowth_ts, consent_ts, 2)
ADL_predict_all(GDPGrowth_ts, consent_ts, 3)
ADL_predict_all(GDPGrowth_ts, consent_ts, 4)

```


## TEST 

```{r test}


consent2 <- read_excel("../Data/FRED Consumer Sentiment.xls", col_names = c("Date", "Spread")) %>% 
  mutate(Date = as.yearqtr(Date), 
         Spread = as.numeric(Spread))

consent2 <- ADL_splice(consent2, example_startyq, example_endyq)

consent2_ts <- ts(consent$Spread, 
                start = c(start_y, start_q), 
                end = c(end_y, end_q), 
                frequency = 4)

```






# COMBINED MODEL 


## Combined: Basic Cleaning

```{r combined cleaning}

num_X <- length(ADL_variables)

X_comb_df <- ts.union(baa_aaa_ts, tspread_ts, fred_hstarts_ts, consent_ts)

if (num_X > 4){
  for (i in 5:num_X){
    # get the new dataset 
    X_new <- get(ADL_variables[i])
    # union it
    X_comb_df <- ts.union(X_comb_df, X_new)
  }
}

# set colnames 
colnames(X_comb_df) <- ADL_variables

```


## Combined: Selecting Best Model - AIC 

```{r combined aic}

comb_AICselector <- function(Y_df, X_combined_df, end_year, end_quarter, dum){
  
  # options is a vector that comprises all the lags of Y and X. 
  # These are the options for permutations and combinations
  options <- c()
  
  # j refers to the number of lags of each variable that we will include.
  for (j in 1:2){
    Y_string = paste("L(", "Y_df", ",", j, ")", sep = "")
    options <- append(options, Y_string)
    
    for (i in 1:num_X){
      var_name = ADL_variables[i]
      X_string = paste("L(", var_name, ",", j, ")", sep = "")
      options <- append(options, X_string)
    }
  }
  
  
  dum_string = as.character(substitute(dum))
  # creates the "GDPGrowth_ts ~ " part
  #start_string = paste("Y_df", " ~ ", sep = "")
  start_string = "Y_df ~ dum + "
  
  # just a really large value
  min_AIC = Inf
  min_AIC_string = ""
  
  # creating the X dataframes 
  for (i in 1:num_X){
    name <- ADL_variables[i]
    # assign name to the variable
    assign(name, X_comb_df[,i])
  }
  
  for (i in 1:4){
    store = combn(options, i)
    length_store = ncol(store)
    
    for (m in 1:length_store){
      elements <- store[,m]
      body_string = ""
      
      for (n in 1:i){
        body_string = paste(body_string, elements[n], sep = " + ")
        # remove the first plus sign
        body_string_up <- substring(body_string, 4)
        
        model_string = paste(start_string, body_string_up, sep = "")
        model_formula = as.formula(model_string)
      
        # create dynlm model 
        model_local <- dynlm(model_formula,
                             start = c(start_y, start_q), 
                             end = c(end_year, end_quarter))
        
        # AIC of model 
        AIC_local <- AIC(model_local)
        
        # if AIC_local < min_AIC, replace the value of min_AIC. 
        # replace min_AIC_string too
        if(AIC_local < min_AIC){
          min_AIC = AIC_local
          min_AIC_string = model_string
        }
      }
    }
  }
  final_string = gsub("dum", dum_string, min_AIC_string)
  # output is the string format of the optimal model formula
  return(final_string)
}


```


# Function for calculating next quarter prediction (combined)

```{r combined next quarter}

ADL_comb_predict <- function(Y_dataframe, X_combined_dataframe,
                          selectors, coefficients, covid_dummy){
  
  Y_string <- as.character(substitute(Y_dataframe))
  covid_dummy_name <- as.character(substitute(covid_dummy))
  
  # creating the X dataframes 
  for (i in 1:num_X){
    name <- ADL_variables[i]
    # assign name to the variable
    assign(name, X_combined_dataframe[,i])
  }
  
  # if there is covid dummy 
  coef_df <- as.data.frame(coefficients)
  coef_row_name <- c(rownames(coef_df))
  
  coef_df <- coef_df %>% 
  mutate(lag_name = gsub("^.*?\\(([^,]+).*", "\\1", coef_row_name), 
         lag_num = str_sub(coef_row_name,-2,-2))
  
  
  # intercept value 
  pred = coefficients[1]
  
  # if covid_dummy is one of the chosen variables
  if (covid_dummy_name %in% coef_row_name){
    # if it is null, ignore 
    if (is.null(coef_df[covid_dummy_name, coef_df$coefficients])){
      pred = pred
    } else {
      temp = coef_df[covid_dummy_name, coef_df$coefficients] * covid_dummy
      pred = temp + pred
    }
  }
  
  # if covid_dummy is one of the chosen variables
  # start looking through the table from row 3
  if (covid_dummy_name %in% coef_row_name){
    start_row = 3
  } else {
    start_row = 2 
  }
  
  num_coeff <- length(coefficients)
  
  for (i in start_row:num_coeff){
    
    # if it's GDPGrowth_ts, read from the Y_dataframe instead 
    if (coef_df[i, 2] == Y_string){
      df <- Y_dataframe
    } else {
      df <- get(coef_df[i, 2])
    }
    coef_value <- coef_df[i, 1]
    tail_num <- as.numeric(coef_df[i, 3])
    
    temp = (tail(df, n = tail_num)[1]) * coef_value
    pred = pred + temp
  }
  
  return(pred)
}




```




# Function for calculating predictions for all time horizons

```{r combined predict all horizons}

ADL_comb_predict_all <- function(Y_dataframe, X_combined_dataframe, f_horizon){
  
  # creating the X dataframes 
  for (i in 1:num_X){
    name <- ADL_variables[i]
    # assign name to the variable
    assign(name, X_comb_df[,i])
  }

  selectors_AIC <- comb_AICselector(Y_dataframe, X_combined_dataframe, 
                                    end_y, end_q, covid_dummy)
  
  Y_string <- as.character(substitute(Y_dataframe))
  selectors_AIC <- gsub("Y_df", Y_string, selectors_AIC)
  
  selectors_AIC <- gsub("covid_dummy", "covid_dummy_ts", selectors_AIC) 
  
  # because of high computation, use this model_formula for all predictions
  model_formula = as.formula(selectors_AIC)
  
  model_AIC <- dynlm(model_formula,
        start = c(start_y, start_q), 
        end = c(end_y, end_q))
  
  pred <- ADL_comb_predict(Y_dataframe, X_combined_dataframe,
                        selectors_AIC, model_AIC$coefficients, covid_dummy_ts)
  
  GDP_df <- as.matrix(Y_dataframe)
  
  # predictions for all X variables
  for (i in 1:num_X){
    # e.g. name is baa_aaa
    name <- substr(ADL_variables[i], 1, nchar(ADL_variables[i]) - 3)
    # e.g. name_df is "baa_aaa_df"
    name_df <- paste(name, "_df", sep = "")
    X_ts <- X_comb_df[,i]
    X_df <- as.matrix(X_ts)
    
    assign(name_df, X_df)
    
    AR_output <- fitAR(get(name_df), 1, covid_dummy)
    pred_name = paste("X", i,"_pred", sep = "")
    
    assign(pred_name, AR_output$pred)
    # to call the new X value, you have to call get(paste(X, i,"_pred", sep = ""))
  }
  
  if (f_horizon == 1){
    pred = pred
  }
  
  else{
    for (i in 2:f_horizon){
      # updating end year & quarter 
      updated_end_yq <- example_endyq + (i - 1)/4
      upd_end_y <- as.numeric(year(updated_end_yq))
      upd_end_q <- as.numeric(quarter(updated_end_yq))
      
      # replace the NA in the last row with the prediction above
      GDP_df <- rbind(GDP_df, pred)
      
      gdp_ts <- ts(GDP_df, 
                  start = c(start_y, start_q), 
                  end = c(upd_end_y, upd_end_q), 
                  frequency = 4)
      
      # X pred
      for (j in 1:num_X){
        name <- substr(ADL_variables[j], 1, nchar(ADL_variables[j]) - 3)
        name_df <- paste(name, "_df", sep = "")
        name_ts <- ADL_variables[j]
        
        X_pred <- get(paste("X", j,"_pred", sep = ""))
        
        curr_df <- get(name_df)
        curr_df <- rbind(curr_df, X_pred)
        
        assign(name_df, curr_df)
        
        curr_ts <- ts(get(name_df),
                      start = c(start_y, start_q), 
                      end = c(upd_end_y, upd_end_q), 
                      frequency = 4)
        
        assign(name_ts, curr_ts)
        
        # get(name_ts) summons the time series
        
      }
      
      # create the combined dataframe with the updated X dataframes 
      
      # this makes X_comb_upd the first ts 
      name_ts_first <- ADL_variables[1]
      X_comb_upd <- get(name_ts_first)
      
      # this loop then updates X_comb_upd
      for (m in 2:num_X){
        name_ts <- ADL_variables[m]
        X_new <- get(name_ts)
        X_comb_upd <- ts.union(X_comb_upd, X_new)
      }
      
      # correct the col names of the combined dataframe 
      colnames(X_comb_upd) <- ADL_variables
      
      # Updating COVID dummy
      upd_covid_dummy = c(covid_dummy, rep(0, i - 1))
      
      upd_covid_dummy_ts <- ts(covid_dummy,
                        start = c(start_y, start_q), 
                        end = c(end_y, end_q), 
                        frequency = 4)
      
      selectors_AIC_local <- gsub("GDPGrowth_ts", "gdp_ts", selectors_AIC) 
      selectors_AIC_local <- gsub("covid_dummy_ts", "upd_covid_dummy_ts", selectors_AIC_local) 
      
      # model based on AIC selection
      model_AIC_local <- dynlm(as.formula(selectors_AIC_local),
            start = c(start_y, start_q), 
            end = c(upd_end_y, upd_end_q))
      
      pred <- ADL_comb_predict(gdp_ts, X_comb_upd, 
                            selectors_AIC_local, model_AIC_local$coefficients, 
                            upd_covid_dummy_ts)
      
      # predictions for all X variables
      for (n in 1:num_X){
        # e.g. name is baa_aaa
        name <- substr(ADL_variables[n], 1, nchar(ADL_variables[n]) - 3)
        # e.g. name_df is "baa_aaa_df"
        name_df <- paste(name, "_df", sep = "")
        X_ts <- X_comb_upd[,n]
        X_df <- as.matrix(X_ts)
        
        assign(name_df, X_df)
        
        AR_output <- fitAR(get(name_df), 1, upd_covid_dummy)
        pred_name = paste("X", n,"_pred", sep = "")
        
        assign(pred_name, AR_output$pred)
      }
    }
  }
  return(pred[[1]])
}


ADL_comb_predict_all(GDPGrowth_ts, X_comb_df, 3)


```
